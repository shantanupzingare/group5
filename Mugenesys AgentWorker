namespace AgentWorker.Core
{
    using Microsoft.Extensions.Configuration;
    using System;

    public static class AppSettingHelper
    {
        static AppSettingHelper()
        {
            Configuration = new ConfigurationBuilder()
             .SetBasePath(ProcessDirectory)
             .AddJsonFile("appsettings.json")
             .Build();
        }

        public static string ProcessDirectory
        {
            get
            {
                return AppDomain.CurrentDomain.BaseDirectory;
            }
        }

        public static IConfigurationRoot Configuration { get; }
    }
}


using AgentWorker.Global;
using AgentWorker.Models.Response;
using BinaryProtocol.Common;
using CTCL.BinaryProtocol.Common.CMA.Enum;
using System.Diagnostics;
using System.Management;
using System.ServiceProcess;

namespace AgentWorker.Core
{
	public class ComponentManager
	{
		private ComponentType componentType;
		private int InstanceId;
		private string exePath=string.Empty;
		private string CmdParameters;
		private Process _process;
		private int PID;
		private string processName;
		ManualResetEvent _mre;
		private bool isRunAsService;
		private string serviceName;
		private bool isRunning;
		private CancellationTokenSource CancellationTokenSource;
		private CancellationToken token;
		public ComponentManager(ComponentInfoData componentInfoData)
		{
			componentType = (ComponentType)componentInfoData.ComponentType;
			InstanceId = componentInfoData.InstanceId;
			exePath = string.IsNullOrEmpty(componentInfoData.ExecutablePath)?string.Empty: componentInfoData.ExecutablePath;
			CmdParameters = componentInfoData.CmdParameters;
			_mre = new ManualResetEvent(false);
			serviceName = componentInfoData.ServiceName;
		}

		public Response StartComponent(bool isRunAsServiceInput, string requestId)
		{
			Response response= new Response();
			isRunAsService= isRunAsServiceInput;
			
			if (_process != null && !_process.HasExited)
			{
				StopComponent();
			}

			if (isRunAsService)
			{
				ServiceController service = new ServiceController(serviceName);
				try
				{
					TimeSpan timeout = TimeSpan.FromMilliseconds(Config.serviceTimerOut);

					service.Start();
					service.WaitForStatus(ServiceControllerStatus.Running, timeout);
					response.Set(StatusCode.Success, $"Service started {serviceName}");

					string query = $"Select ProcessId FROM Win32_Service WHERE Name = {serviceName}";
					ManagementObjectSearcher searcher = new ManagementObjectSearcher(query);
					ManagementObjectCollection collections = searcher.Get();

					foreach (ManagementObject collection in collections)
					{
						int processId = 0;
						processId = Convert.ToInt32(collection["ProcessId"]);
						Process process = Process.GetProcessById(processId);
						if (process != null)
						{
							_process = process;
							processName = _process.ProcessName.Trim();
							StartComponentOperationInfoTracking();
							// send message on websocket of running  process;
						}
					}
				}
				catch (Exception ex)
				{
					Log.Error($"Exception occured while running service {serviceName} | {ex}");
					response.Set(StatusCode.Failure, $"Exception occured while running service {serviceName} | {ex}");
				}
			}
			else
			{
				var cmdParameters = $"{CmdParameters} --rid={requestId}"; 
				_process = new Process();
				_process.StartInfo = new ProcessStartInfo()
				{
					FileName = exePath,
					Arguments = cmdParameters,
					UseShellExecute = true,
					RedirectStandardOutput = false,
					RedirectStandardError = false,
					CreateNoWindow = false
				};
				try
				{
					_process.Start();
					PID = _process.Id;
					processName = _process.ProcessName.Trim();
					ConsoleLog.ConsoleWrite($"Process started with PID {_process.Id} | Name {_process.ProcessName} | instanceId {InstanceId}");
					response.Set(StatusCode.Success, $"Process started with PID {_process.Id} | Name {_process.ProcessName} | instanceId {InstanceId}");
				 	//StartComponentOperationInfoTracking();
				}

				catch (Exception ex)
				{
					Log.Error($"Exception occured while running the process | instanceId {InstanceId} {ex} ");
					response.Set(StatusCode.Failure, $"Exception occured while running the process | instanceId {InstanceId} {ex}");
				}
			}

			return response;
		}

		public Response StopComponent()
		{
			Response response= new Response();
			if (isRunAsService)
			{
				ServiceController service = new ServiceController(serviceName);
				try
				{
					TimeSpan timeout = TimeSpan.FromMilliseconds(Config.serviceTimerOut);
					CancellationTokenSource.Cancel();
					service.Stop();
					service.WaitForStatus(ServiceControllerStatus.Stopped, timeout);
                    SetIsRunning(false);
                    response.Set(StatusCode.Success, $"Service stopped {serviceName}");
				
				}
				catch(Exception ex)
				{
					Log.Error($"Exception occured while stopping service {serviceName}");
					response.Set(StatusCode.Failure, $"Exception occured while stopping service {serviceName}");
				}
			}
			else
			{
				if (_process != null && !_process.HasExited)
				{
					try
					{
						if(CancellationTokenSource!=null)
							CancellationTokenSource.Cancel();
						_process.Kill();
						_process.WaitForExit();
						SetIsRunning(false);
						ConsoleLog.ConsoleWrite($"Process stopped {PID} | Name {processName} | instanceId {InstanceId}");
						response.Set(StatusCode.Success, $"Process stopped {PID} | Name {processName} | instanceId {InstanceId}");
					}
					catch (Exception ex)
					{
						Log.Error($"An error occured while stopping the process | instanceId {InstanceId} : {ex}");
						response.Set(StatusCode.Failure, $"An error occured while stopping the process | instanceId {InstanceId} : {ex}");
					}

				}
				else
				{
					Log.Info($"Process is already stopped or was never started | instanceId {InstanceId} ");
					response.Set(StatusCode.Failure, $"Process is already stopped or was never started {processName} | instanceId {InstanceId}");
				}
			}
			return response;
		}

		public bool GetIsRunning()
		{
			return isRunning;
		}

		public void SetIsRunning(bool flag)
		{
			isRunning = flag;
			if(isRunning)
            {
                if (_process == null || _process.Id == 0 || _process.HasExited)
                {
                    SetExistingProcess();
                }
            }
			else
			{
				_process = null;
			}
		}
		
		public void SetExistingProcess()
		{
			try
			{
				string wmiQery = string.Format("select CommandLine, ProcessId, Name from Win32_Process where ExecutablePath='{0}'", exePath.Replace("\\", "\\\\"));
				ManagementObjectSearcher searcher = new ManagementObjectSearcher(wmiQery);
				ManagementObjectCollection collections = searcher.Get();

				foreach (ManagementObject collection in collections)
				{
					Console.WriteLine("{0} | {1} | {2}", collection["CommandLine"], collection["ProcessId"], collection["Name"]);

					string ags = $"{collection["Name"]} {componentType}_{InstanceId}";

					var processId = GetProcessIdOfExistingProcess(ags);
					Process process = Process.GetProcessById(processId);
					if (process != null)
					{
						_process = process;
						processName = _process.ProcessName;
						StartComponentOperationInfoTracking();
						// send message on websocket of running  process;
					}
				}
			}
			catch (Exception ex)
			{
				Log.Error($"Exception occured while setting existing process | {ex}");
				// send message on websocket;
			}
			
		}

		private void StartComponentOperationInfoTracking()
		{
			if(CancellationTokenSource != null)
			{
				CancellationTokenSource.Cancel();
			}
			CancellationTokenSource = new CancellationTokenSource();
			token = CancellationTokenSource.Token;
			try
			{
				Task.Factory.StartNew(() =>
				{
					while (true)
					{
						_mre.WaitOne(10000);
						if (token.IsCancellationRequested) break;
						
						var cpu = GetCPU();
						var ram = GetRam();
						Console.WriteLine($"{componentType} | {InstanceId} | CPU usage {cpu:F2}% | Working SET Memory {ram:F2} MB");
						//send to FE on websocket
						ComponentTechincalInfo componentTechincalInfo = new()
						{
							MessageCode = (int)CMA_OpCode.CMA_TECHNICAL_PARAM_REQ,
							ComponentType = (int)componentType,
							InstanceId = InstanceId,
							CPUPercentage = cpu,
							RAMUsage = ram,
							TimeStamp = DateTime.Now
						};
						CoreProcess.wsClientManager.Enqueue(componentTechincalInfo);
					};
				}, token);
			}
			catch (Exception ex)
			{
				Log.Error($"Exception occured in technical parametrs {ex}");
			}
		}

		private double GetCPU()
		{
			try
            {
                if (_process != null && !_process.HasExited)
                {
                    _process.Refresh();
                    TimeSpan startCpu = _process.TotalProcessorTime;
                    DateTime startTIme = DateTime.UtcNow;
                    Thread.Sleep(1000);
                    TimeSpan endCPU = _process.TotalProcessorTime;
                    DateTime endTime = DateTime.UtcNow;

                    double cpuUsedMs = (endCPU - startCpu).TotalMilliseconds;
                    double totalMS = (endTime - startTIme).TotalMilliseconds;
                    return cpuUsedMs / Environment.ProcessorCount / totalMS * 100;
                }
                return 0.0;
            }
			catch (Exception ex)
            {
                Log.Error($"Error while Getting CPU | {ex.Message}");
                return 0.0;
            }
		}

		private double GetRam()
		{
			try
            {
                if (_process != null && !_process.HasExited)
                {
                    _process.Refresh();
                    Thread.Sleep(1000);
                    return (_process.WorkingSet64) / 1024.0 / 1024.0;
                }
                return 0.0;
            }
			catch (Exception ex)
			{
				Log.Error($"Error while Getting RAM | {ex.Message}");
				return 0.0;
			}
		}

		private int GetProcessIdOfExistingProcess(string args)
		{
			int processId = 0;
			try
			{
				Process process = new Process();
				process.StartInfo = new ProcessStartInfo()
				{
					FileName = Config.batchFilePath,
					Arguments = args,
					UseShellExecute = false,
					RedirectStandardOutput = true,
					RedirectStandardError = true,
					CreateNoWindow = true,
				};
				process.Start();

				string[] output = process.StandardOutput.ReadToEnd().Split("\r\n");
				string error = process.StandardError.ReadToEnd();
				//set processId
				if (!string.IsNullOrEmpty(output[0]))
				{
					processId = Convert.ToInt32(output[0]);
				}
				process.WaitForExit();

			}
			catch (Exception ex)
			{
				Log.Error($"Exception occured while reading batch output | {ex}");
			}
			
			return processId;
		}

	}

}



using BinaryProtocol.Common;
using Exchange.Logs;
using Serilog.Core;
using Serilog.Events;
using Serilog;
using AgentWorker.Global;
using AgentWorker.Processor;
using System.Net;
using AgentWorker.MasterCache;
using AgentWorker.Models.Response;
using System.Diagnostics;
using CTCL.BinaryProtocol.Common.CMA.Enum;

namespace AgentWorker.Core
{
    public class CoreProcess
    {
        public static Response response;
        private static LogProcessor logProcessor;
        public static InterfaceProcessor interfaceProcessor;
        public static ComponentHandshakeManager handshakeManager;
        public static FileDataCache fileDataCache;
        public static WebSocketClientManager wsClientManager;
        public static List<FilePathInfo> filePathInfo;
        public static ComponentDataCache compDataCache;
        public static Dictionary<(ComponentType, int), ComponentManager> componentManager;
        public static Dictionary<int, SpanFileInfo> spanFileInfo;
        public static Dictionary<int, SpanFileInfo> varElmFileInfo;
        public static Dictionary<int, FileSystemWatcher> fileSystemWatcherDict;

        public static Response Initialize()
        {
            response = new();
            LogConfiguration logConfiguration = new LogConfiguration
            {
                FilesizeLimitBytes = 50000000,
                LogFileNameWithPath = Config.logfile,
                LoggingLevelSwitch = new LoggingLevelSwitch
                {
                    MinimumLevel = Config.logLevel == 0 ? LogEventLevel.Debug : (LogEventLevel)Config.logLevel,
                },
                OutputTemplate = "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u5}] {Message:lj}{NewLine}{Exception}",
                RetainedFileCount = Config.logFileCount,
                RollingInterval = RollingInterval.Day,
                RollOnFileSizeLimit = true,
            };

            LogType logType = (LogType)Config.logLevel;

            if (logProcessor == null)
            {
                logProcessor = new LogProcessor(logConfiguration);
            }

            spanFileInfo = new();
            varElmFileInfo = new();
            fileDataCache = new();
            compDataCache = new();
            handshakeManager = new();
            componentManager = new();
            fileSystemWatcherDict = new();
            InitLocalIp();
            //Config.GetConfigurationSettings();
            //CacheOnLoad.LoadAllCacheData();
            interfaceProcessor = new();
            //interfaceProcessor.Init();
            //interfaceProcessor.InitListeners();
            wsClientManager = new(Config.WebSocketUrl);
            return new Response()
            {
                Message = ""
            };
        }
        public static Response SendToLogQueue(LogObject data)
        {
            if (!data.Equals(default(LogObject)) && logProcessor != null)
            {
                return logProcessor.Enqueue(data);
            }
            else if (logProcessor == null)
            {
                return response.Set(StatusCode.OMS_Failure, "logProcessor is null");
            }
            else
            {
                return response.Set(StatusCode.OMS_Failure, "data is null");
            }
        }
        public static Response InitLocalIp()
        {
            Response response = new Response();
            Global.Log.Info($"Fetching Local IP adress");
            var host = Dns.GetHostEntry(Dns.GetHostName());
            foreach (var ip in host.AddressList)
            {
                if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)
                {
                    Config.LocalIp = ip.ToString();
                    Global.Log.Info($"Local IP adress {Config.LocalIp}");
                }
            }
            return response.Set(StatusCode.Success, "Sucess");
        }

        public static Response StartComponent(ComponentType componentType, int instanceId, bool isRunAsService, string requestID)
        {
            Response response = new Response();
            if (componentManager.TryGetValue((componentType, instanceId), out var component) && component != null)
            {
                response = component.StartComponent(isRunAsService, requestID);
            }
            else
            {
                response.Set(StatusCode.Failure, $"Component infomation is not found for {componentType} and instanceID {instanceId}");
            }

            ComponentStatus componentStatus = new()
            {
                ComponentType = (int)componentType,
                InstanceId = instanceId,
                IsSucessStatus = false,
                Message = response.Message,
                MessageCode = 0
            };
            //send on web socket

            return response;
        }

        public static Response StopComponent(ComponentType componentType, int instanceId)
        {
            Response response = new Response();
            if (componentManager.TryGetValue((componentType, instanceId), out var component) && component != null)
            {
                response = component.StopComponent();
            }
            else
            {
                response.Set(StatusCode.Failure, $"Component infomation is not found for {componentType} and instanceID {instanceId}");
            }

            //send on web socket 
            var resp = Helper.Helper.PrepareComponentStatus((int)componentType, instanceId, response.StatusCode == StatusCode.Success ? (int)CMA_StatusCode.Stopped : (int)CMA_StatusCode.Completed, "");
            if (response.StatusCode == StatusCode.Success)
            {
                SetIsRunning(componentType, instanceId, false);
            }
            wsClientManager.Enqueue(resp);
            return response;
        }

        public static Response CopyFileData(string sourcePath, string destinationPath)
        {
            Response response = new();

            try
            {
                if (!File.Exists(destinationPath))
                {
                    File.Copy(sourcePath, destinationPath);
                    response.Set(StatusCode.Success, $"File copied from {sourcePath} to {destinationPath} sucessfully");
                }
                else
                {
                    response.Set(StatusCode.Failure, $"File already exists");
                }
            }
            catch (Exception ex)
            {
                response.Set(StatusCode.Failure, $"Exception occured while copy file {ex}");
            }

            return response;
        }

        public static void SetIsRunning(ComponentType componentType, int instanceId, bool flag)
        {
            Response response = new Response();
            if (componentManager.TryGetValue((componentType, instanceId), out var component) && component != null)
            {
                component.SetIsRunning(flag);
            }
        }

        public static bool GetIsRunning(ComponentType componentType, int instanceId)
        {
            Response response = new Response();
            if (componentManager.TryGetValue((componentType, instanceId), out var component) && component != null)
            {
                return component.GetIsRunning();
            }
            return false;
        }

        public static void SetExistingProcess(ComponentType componentType, int instanceId)
        {
            if (componentManager.TryGetValue((componentType, instanceId), out var component) && component != null)
            {
                component.SetExistingProcess();
            }
        }

        public static void SendTechnicalDataOfServer()
        {
            ManualResetEvent _mre = new ManualResetEvent(false);
            Task.Factory.StartNew(() =>
            {
                while (true)
                {
                    _mre.WaitOne(10000);
                    var cpu = GetCPUValue();
                    var ram = GetMemValue();

                    //send to FE on websocket
                    ComponentTechincalInfo componentTechincalInfo = new()
                    {
                        MessageCode = (int)CMA_OpCode.CMA_TECHNICAL_PARAM_REQ,
                        ComponentType = -1,
                        InstanceId = Config.AgentWorkerId,
                        CPUPercentage = cpu,
                        RAMUsage = ram,
                    };
                    wsClientManager.Enqueue(componentTechincalInfo);
                }
            });
        }

        private static int GetCPUValue()
        {
            int result = 0;
            try
            {
                var cpuCounter = new PerformanceCounter("Processor", "% Processor Time", "_Total");
                cpuCounter.NextValue();
                Thread.Sleep(1000);
                return (int)cpuCounter.NextValue();
            }
            catch (Exception ex)
            {
                Global.Log.Error($"Exception occured while fetching server cpu | {ex}");
            }
            return result;
        }

        private static int GetMemValue()
        {
            int result = 0;
            try
            {
                var memCounter = new PerformanceCounter("Memory", "% Committed Bytes in  Use");
                return (int)memCounter.NextValue();
            }
            catch (Exception ex)
            {
                Global.Log.Error($"Exception occured while fetching server ram | {ex}");
            }
            return result;
        }

        public class SpanFileInfo
        {
            public string FileName;
            public DateTime TimeStamp;
        }

        public static void InitWatcher(int id, string sourcePath)
        {
            //FileWatcherClass fileWatcherClass = new();
            FileSystemWatcher fileSystemWatcher = new(sourcePath);
            fileSystemWatcher.Created += new FileSystemEventHandler(OnChanged);
            fileSystemWatcher.EnableRaisingEvents = true;
            fileSystemWatcherDict.TryAdd(id, fileSystemWatcher);

            Console.WriteLine($"Watcher init for span {sourcePath}");
        }
        private static void OnChanged(object source, FileSystemEventArgs e)
        {
            Console.WriteLine($"Onchange invoked {e.FullPath}");
            System.IO.FileInfo fileInfo = new(e.FullPath);
            var fileName = fileInfo.Name;
            var filePath = e.FullPath;

            DirectoryInfo diretory = new DirectoryInfo(filePath);
            string foldername = diretory.Parent.Name;

            if (foldername == "span")
            {
                var spanFileInfo = CoreProcess.filePathInfo.Where(y => y.FileName == "span").FirstOrDefault();
                if (spanFileInfo != null)
                {
                    var destinationPath = spanFileInfo.DestinationPath + "/" + fileName;

                    var resp = CoreProcess.CopyFileData(filePath, destinationPath);
                    if (resp.StatusCode == StatusCode.Success)
                    {
                        var spanFileCount = CoreProcess.spanFileInfo.Count + 1;
                        CoreProcess.spanFileInfo.TryAdd(spanFileCount, new() { FileName = fileName, TimeStamp = DateTime.Now });
                        SendAfterBodFileUploadStatus(spanFileInfo, true, resp.Message, fileName);
                        Global.Log.Info(resp.Message);
                    }
                }
            }
            else if (foldername == "varelm")
            {
                var varElmInfo = CoreProcess.filePathInfo.Where(y => y.FileName == "varelm").FirstOrDefault();
                if (varElmInfo != null)
                {
                    var destinationPath = varElmInfo.DestinationPath + "/" + fileName;

                    var resp = CoreProcess.CopyFileData(filePath, destinationPath);
                    if (resp.StatusCode == StatusCode.Success)
                    {
                        var elmFile = CoreProcess.varElmFileInfo.Count + 1;
                        CoreProcess.varElmFileInfo.TryAdd(elmFile, new() { FileName = fileName, TimeStamp = DateTime.Now });
                        SendAfterBodFileUploadStatus(varElmInfo, true, resp.Message, fileName);
                        Global.Log.Info(resp.Message);
                    }
                }
            }


        }
        private static void SendAfterBodFileUploadStatus(FilePathInfo filePathInfo, bool status, string message, string fileName)
        {
            FileStatus fileStatus = new()
            {
                MessageCode = (int)CMA_OpCode.FILE_UPLOAD_CONFIRMATION,
                BrokerId = Config.BrokerId,
                SiteId = Config.SiteId,
                AgentId = Config.AgentWorkerId,
                FileName = fileName,
                FileType = filePathInfo.FileType,
                Segment = filePathInfo.Segment,
                IsSucessStatus = status,
                Message = message,
                TimeStamp = DateTime.Now
            };
            CoreProcess.wsClientManager.Enqueue(fileStatus);
        }
    }
    public class FileWatcherClass
    {
        public FileSystemWatcher fileSystemWatcher;
    }
}



using BinaryProtocol.Common;
using Exchange.Logs;
using Serilog.Core;
using Serilog.Events;
using Serilog;
using AgentWorker.Global;
using AgentWorker.Processor;
using System.Net;
using AgentWorker.MasterCache;
using AgentWorker.Models.Response;
using System.Diagnostics;
using CTCL.BinaryProtocol.Common.CMA.Enum;

namespace AgentWorker.Core
{
    public class CoreProcess
    {
        public static Response response;
        private static LogProcessor logProcessor;
        public static InterfaceProcessor interfaceProcessor;
        public static ComponentHandshakeManager handshakeManager;
        public static FileDataCache fileDataCache;
        public static WebSocketClientManager wsClientManager;
        public static List<FilePathInfo> filePathInfo;
        public static ComponentDataCache compDataCache;
        public static Dictionary<(ComponentType, int), ComponentManager> componentManager;
        public static Dictionary<int, SpanFileInfo> spanFileInfo;
        public static Dictionary<int, SpanFileInfo> varElmFileInfo;
        public static Dictionary<int, FileSystemWatcher> fileSystemWatcherDict;

        public static Response Initialize()
        {
            response = new();
            LogConfiguration logConfiguration = new LogConfiguration
            {
                FilesizeLimitBytes = 50000000,
                LogFileNameWithPath = Config.logfile,
                LoggingLevelSwitch = new LoggingLevelSwitch
                {
                    MinimumLevel = Config.logLevel == 0 ? LogEventLevel.Debug : (LogEventLevel)Config.logLevel,
                },
                OutputTemplate = "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u5}] {Message:lj}{NewLine}{Exception}",
                RetainedFileCount = Config.logFileCount,
                RollingInterval = RollingInterval.Day,
                RollOnFileSizeLimit = true,
            };

            LogType logType = (LogType)Config.logLevel;

            if (logProcessor == null)
            {
                logProcessor = new LogProcessor(logConfiguration);
            }

            spanFileInfo = new();
            varElmFileInfo = new();
            fileDataCache = new();
            compDataCache = new();
            handshakeManager = new();
            componentManager = new();
            fileSystemWatcherDict = new();
            InitLocalIp();
            //Config.GetConfigurationSettings();
            //CacheOnLoad.LoadAllCacheData();
            interfaceProcessor = new();
            //interfaceProcessor.Init();
            //interfaceProcessor.InitListeners();
            wsClientManager = new(Config.WebSocketUrl);
            return new Response()
            {
                Message = ""
            };
        }
        public static Response SendToLogQueue(LogObject data)
        {
            if (!data.Equals(default(LogObject)) && logProcessor != null)
            {
                return logProcessor.Enqueue(data);
            }
            else if (logProcessor == null)
            {
                return response.Set(StatusCode.OMS_Failure, "logProcessor is null");
            }
            else
            {
                return response.Set(StatusCode.OMS_Failure, "data is null");
            }
        }
        public static Response InitLocalIp()
        {
            Response response = new Response();
            Global.Log.Info($"Fetching Local IP adress");
            var host = Dns.GetHostEntry(Dns.GetHostName());
            foreach (var ip in host.AddressList)
            {
                if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)
                {
                    Config.LocalIp = ip.ToString();
                    Global.Log.Info($"Local IP adress {Config.LocalIp}");
                }
            }
            return response.Set(StatusCode.Success, "Sucess");
        }

        public static Response StartComponent(ComponentType componentType, int instanceId, bool isRunAsService, string requestID)
        {
            Response response = new Response();
            if (componentManager.TryGetValue((componentType, instanceId), out var component) && component != null)
            {
                response = component.StartComponent(isRunAsService, requestID);
            }
            else
            {
                response.Set(StatusCode.Failure, $"Component infomation is not found for {componentType} and instanceID {instanceId}");
            }

            ComponentStatus componentStatus = new()
            {
                ComponentType = (int)componentType,
                InstanceId = instanceId,
                IsSucessStatus = false,
                Message = response.Message,
                MessageCode = 0
            };
            //send on web socket

            return response;
        }

        public static Response StopComponent(ComponentType componentType, int instanceId)
        {
            Response response = new Response();
            if (componentManager.TryGetValue((componentType, instanceId), out var component) && component != null)
            {
                response = component.StopComponent();
            }
            else
            {
                response.Set(StatusCode.Failure, $"Component infomation is not found for {componentType} and instanceID {instanceId}");
            }

            //send on web socket 
            var resp = Helper.Helper.PrepareComponentStatus((int)componentType, instanceId, response.StatusCode == StatusCode.Success ? (int)CMA_StatusCode.Stopped : (int)CMA_StatusCode.Completed, "");
            if (response.StatusCode == StatusCode.Success)
            {
                SetIsRunning(componentType, instanceId, false);
            }
            wsClientManager.Enqueue(resp);
            return response;
        }

        public static Response CopyFileData(string sourcePath, string destinationPath)
        {
            Response response = new();

            try
            {
                if (!File.Exists(destinationPath))
                {
                    File.Copy(sourcePath, destinationPath);
                    response.Set(StatusCode.Success, $"File copied from {sourcePath} to {destinationPath} sucessfully");
                }
                else
                {
                    response.Set(StatusCode.Failure, $"File already exists");
                }
            }
            catch (Exception ex)
            {
                response.Set(StatusCode.Failure, $"Exception occured while copy file {ex}");
            }

            return response;
        }

        public static void SetIsRunning(ComponentType componentType, int instanceId, bool flag)
        {
            Response response = new Response();
            if (componentManager.TryGetValue((componentType, instanceId), out var component) && component != null)
            {
                component.SetIsRunning(flag);
            }
        }

        public static bool GetIsRunning(ComponentType componentType, int instanceId)
        {
            Response response = new Response();
            if (componentManager.TryGetValue((componentType, instanceId), out var component) && component != null)
            {
                return component.GetIsRunning();
            }
            return false;
        }

        public static void SetExistingProcess(ComponentType componentType, int instanceId)
        {
            if (componentManager.TryGetValue((componentType, instanceId), out var component) && component != null)
            {
                component.SetExistingProcess();
            }
        }

        public static void SendTechnicalDataOfServer()
        {
            ManualResetEvent _mre = new ManualResetEvent(false);
            Task.Factory.StartNew(() =>
            {
                while (true)
                {
                    _mre.WaitOne(10000);
                    var cpu = GetCPUValue();
                    var ram = GetMemValue();

                    //send to FE on websocket
                    ComponentTechincalInfo componentTechincalInfo = new()
                    {
                        MessageCode = (int)CMA_OpCode.CMA_TECHNICAL_PARAM_REQ,
                        ComponentType = -1,
                        InstanceId = Config.AgentWorkerId,
                        CPUPercentage = cpu,
                        RAMUsage = ram,
                    };
                    wsClientManager.Enqueue(componentTechincalInfo);
                }
            });
        }

        private static int GetCPUValue()
        {
            int result = 0;
            try
            {
                var cpuCounter = new PerformanceCounter("Processor", "% Processor Time", "_Total");
                cpuCounter.NextValue();
                Thread.Sleep(1000);
                return (int)cpuCounter.NextValue();
            }
            catch (Exception ex)
            {
                Global.Log.Error($"Exception occured while fetching server cpu | {ex}");
            }
            return result;
        }

        private static int GetMemValue()
        {
            int result = 0;
            try
            {
                var memCounter = new PerformanceCounter("Memory", "% Committed Bytes in  Use");
                return (int)memCounter.NextValue();
            }
            catch (Exception ex)
            {
                Global.Log.Error($"Exception occured while fetching server ram | {ex}");
            }
            return result;
        }

        public class SpanFileInfo
        {
            public string FileName;
            public DateTime TimeStamp;
        }

        public static void InitWatcher(int id, string sourcePath)
        {
            //FileWatcherClass fileWatcherClass = new();
            FileSystemWatcher fileSystemWatcher = new(sourcePath);
            fileSystemWatcher.Created += new FileSystemEventHandler(OnChanged);
            fileSystemWatcher.EnableRaisingEvents = true;
            fileSystemWatcherDict.TryAdd(id, fileSystemWatcher);

            Console.WriteLine($"Watcher init for span {sourcePath}");
        }
        private static void OnChanged(object source, FileSystemEventArgs e)
        {
            Console.WriteLine($"Onchange invoked {e.FullPath}");
            System.IO.FileInfo fileInfo = new(e.FullPath);
            var fileName = fileInfo.Name;
            var filePath = e.FullPath;

            DirectoryInfo diretory = new DirectoryInfo(filePath);
            string foldername = diretory.Parent.Name;

            if (foldername == "span")
            {
                var spanFileInfo = CoreProcess.filePathInfo.Where(y => y.FileName == "span").FirstOrDefault();
                if (spanFileInfo != null)
                {
                    var destinationPath = spanFileInfo.DestinationPath + "/" + fileName;

                    var resp = CoreProcess.CopyFileData(filePath, destinationPath);
                    if (resp.StatusCode == StatusCode.Success)
                    {
                        var spanFileCount = CoreProcess.spanFileInfo.Count + 1;
                        CoreProcess.spanFileInfo.TryAdd(spanFileCount, new() { FileName = fileName, TimeStamp = DateTime.Now });
                        SendAfterBodFileUploadStatus(spanFileInfo, true, resp.Message, fileName);
                        Global.Log.Info(resp.Message);
                    }
                }
            }
            else if (foldername == "varelm")
            {
                var varElmInfo = CoreProcess.filePathInfo.Where(y => y.FileName == "varelm").FirstOrDefault();
                if (varElmInfo != null)
                {
                    var destinationPath = varElmInfo.DestinationPath + "/" + fileName;

                    var resp = CoreProcess.CopyFileData(filePath, destinationPath);
                    if (resp.StatusCode == StatusCode.Success)
                    {
                        var elmFile = CoreProcess.varElmFileInfo.Count + 1;
                        CoreProcess.varElmFileInfo.TryAdd(elmFile, new() { FileName = fileName, TimeStamp = DateTime.Now });
                        SendAfterBodFileUploadStatus(varElmInfo, true, resp.Message, fileName);
                        Global.Log.Info(resp.Message);
                    }
                }
            }


        }
        private static void SendAfterBodFileUploadStatus(FilePathInfo filePathInfo, bool status, string message, string fileName)
        {
            FileStatus fileStatus = new()
            {
                MessageCode = (int)CMA_OpCode.FILE_UPLOAD_CONFIRMATION,
                BrokerId = Config.BrokerId,
                SiteId = Config.SiteId,
                AgentId = Config.AgentWorkerId,
                FileName = fileName,
                FileType = filePathInfo.FileType,
                Segment = filePathInfo.Segment,
                IsSucessStatus = status,
                Message = message,
                TimeStamp = DateTime.Now
            };
            CoreProcess.wsClientManager.Enqueue(fileStatus);
        }
    }
    public class FileWatcherClass
    {
        public FileSystemWatcher fileSystemWatcher;
    }
}




using AgentWorker.Global;
using AgentWorker.Listener;
using BinaryProtocol.Common;
using CTCL.CacheManagement.ComponentSessionManager;
using Utility.ComponentInstance;

namespace AgentWorker.Core
{
    public class InterfaceProcessor
    {
        ComponentInstanceSetup componentInstanceSetup;
        private static Dictionary<string, ListenerOfMQ> listenerFromMQ; // All Listener 
        public ComponentSessionManager componentSessionManager;

        public InterfaceProcessor()
        {
            //componentInstanceSetup = new ComponentInstanceSetup(Config.connectionString);
            listenerFromMQ = new();
            componentSessionManager = new();
        }
        public Response Init()
        {
            Response response = new Response();
            var omsInterfaces = componentInstanceSetup.GetInterface(ComponentType.AgentWorker, Config.AgentWorkerId); // interfaces.Tables[0];

            if (omsInterfaces.StatusCode != StatusCode.Success)
            {
                return response.Set(StatusCode.OMS_Error, "My Interfaces couldn't be loaded.." + omsInterfaces.Message);
            }

            //int i = 0;
            foreach (var component in (List<ComponentInstanceInterface>)omsInterfaces.ExtraInfo)
            {
                var queueConfiguration = new QueueConfiguration
                {
                    ExchangeName = component.Configuration.ExchangeName,
                    HostName = component.Configuration.HostName,
                    MQName = component.Configuration.MQName,
                    PassWord = component.Configuration.PassWord,
                    Port = component.Configuration.Port,
                    UserName = component.Configuration.UserName,
                    VirtualHost = component.Configuration.VirtualHost
                };
                //AgentWorker as Destination
                if (component.DestComponentInfo.ComponentType == ComponentType.AgentWorker && component.DestComponentInfo.InstanceId == Config.AgentWorkerId)
                {
                    ListenerOfMQ listenerOfMQ;
                    if (!listenerFromMQ.TryGetValue(component.Route, out listenerOfMQ))
                    {
                        listenerOfMQ = new ListenerOfMQ(queueConfiguration);
                        listenerFromMQ.Add(component.Route, listenerOfMQ);
                    }
                    //Add Source
                    listenerOfMQ.AddSource(component.SourceComponentInfo);
                }
            }
            return response.Set(StatusCode.Success, "Interfaces loaded.." + omsInterfaces.Message);
        }
        public Response InitNew(int srcComponentId, int srcInstanceId)
        {
            Response response = new Response();

            string nvcRoute = $"{((ComponentType)srcComponentId).ToString()}{srcInstanceId}_{ComponentType.AgentWorker}{Config.AgentWorkerId}|" +
                $"{((ComponentType)srcComponentId).ToString()}{srcInstanceId}_{ComponentType.AgentWorker}{Config.AgentWorkerId}|" +
                $"{Config.RabbitLogin}|{Config.RabbitPwd}|/|{Config.RabbitIp}|{Config.RabbitPort}";

            ComponentType srcCompId = (ComponentType)srcComponentId;
            int srcInstId = srcInstanceId;

            ComponentType destCompId = (ComponentType)ComponentType.AgentWorker;
            int destInstId = Config.AgentWorkerId;

            var sep = nvcRoute.Split('|');
            if (sep.Length != 7)
            {
                return response.Set(StatusCode.Failure, "Route is not proper!!!");
            }

            string ExName = sep[0];
            string MQName = sep[1];
            string UserName = sep[2];
            string PassWord = sep[3];
            string VirtualHost = sep[4];
            string HostName = sep[5];
            int Port = Convert.ToInt32(sep[6]);

            ComponentInstanceInterface componentInstanceInterface = new();
            componentInstanceInterface.Configuration = new()
            {
                ExchangeName = ExName,
                MQName = MQName,
                UserName = UserName,
                PassWord= PassWord,
                VirtualHost = VirtualHost,
                HostName = HostName,
                Port = Port,
            };
            componentInstanceInterface.Route = nvcRoute;
            componentInstanceInterface.DestComponentInfo = new ComponentInfo
            {
                ComponentType = destCompId,
                InstanceId = destInstId
            };

            componentInstanceInterface.SourceComponentInfo = new ComponentInfo
            {
                ComponentType = srcCompId,
                InstanceId = srcInstId
            };

            ListenerOfMQ listenerOfMQ;
            if (!listenerFromMQ.TryGetValue(componentInstanceInterface.Route, out listenerOfMQ))
            {
                listenerOfMQ = new ListenerOfMQ(componentInstanceInterface.Configuration);
                listenerFromMQ.Add(componentInstanceInterface.Route, listenerOfMQ);
            }
            //Add Source
            listenerOfMQ.AddSource(componentInstanceInterface.SourceComponentInfo);
            InitListeners(listenerOfMQ);
            return response.Set(StatusCode.Success, "Interfaces loaded..");
        }
        public void InitListeners(ListenerOfMQ mq)
        {
            ConsoleLog.ConsoleWrite("INIT RABBIT");

            var componentInfoData = mq.GetComponentInfo();
            ComponentSession dbSession = new();
            dbSession.ComponentType = componentInfoData.Item1;
            dbSession.instanceId = componentInfoData.Item2;
            componentSessionManager.Add(dbSession);
            var sessionAdd = componentSessionManager.Get(componentInfoData.Item1, componentInfoData.Item2);
            if (sessionAdd.Item1.StatusCode == StatusCode.Success)
            {
                mq.AddComponentSession(sessionAdd.Item2);
            }

            var mqRes = mq.Initialize();
            // ConsoleLog.ConsoleWrite($"INIT RABBIT COMPLETE {componentInfoData.Item1}");
            ConsoleLog.ConsoleWrite($"INIT RABBIT COMPLETE ");
        }
    }
}



using AgentWorker.Global;
using AgentWorker.Models.Request;
using CTCL.BinaryProtocol.Common.CMA.Enum;
using CTCL.BinaryProtocol.Common.CTCL;
using CTCL.WebSocketDotNetty;
using Utility.Queueing;

namespace AgentWorker.Core
{
	public class WebSocketClientManager
    {
        private InteractiveProcessQueue _interactiveProcessQueue;
		private WebSocketClient _client;
        private ProcessQueue<object> queue;
        private Thread thread;

        public WebSocketClientManager(string url)
        {
            queue = new ProcessQueue<object>();
            _interactiveProcessQueue = new InteractiveProcessQueue();
			_client = new WebSocketClient();
			_client.OnMessageReceived += OnDataReceived;
			_client.OnClientConnect += OnClientConnect;
			_client.OnClientDisconnect += OnClientDisConnect;
			_client.init();
            thread = new Thread(new ThreadStart(ListenQueue));
            thread.Start();
            Init(url);
		}

		private void Init(string url)
		{
			Uri uri = new Uri(url);
			_client.ConnectAsync(uri);
		}

		private void OnDataReceived(object message, bool isBinaryMessage)
		{
			var data = message.ToString();
			_interactiveProcessQueue.Enqueue(data);
		}

		private void OnClientConnect()
		{
			Log.Info("Web socket connected");

            AgentHandshakeReq handshakeReq = PrepareHandshakeReq();
            SendNew(handshakeReq);
		}

		private void OnClientDisConnect()
		{
			Log.Info("Web socket Disconnected");
		}

		private void Send(object res)
		{
            _client.SendAsync(res);
        }
        private void SendNew(object res)
        {
            _client.SendAsyncNew(res);
        }

        public void Enqueue(object data)
        {
            queue.Enqueue(data);
        }

        private void ListenQueue()
        {
            while (true)
            {
                if (queue.TryDequeue(out object res))
                {
                    Process(res);
                }
            }
        }

        private void Process(object res)
        {
            try
            {
                SendNew(res);
            }
            catch (Exception ex)
            {
                Log.Error(ex.Message);
            }
        }
        private AgentHandshakeReq PrepareHandshakeReq()
        {
            AgentHandshakeReq handshakeReq = new()
            {
                MessageCode = (int)CMA_OpCode.AGENT_HANDSHAKE_REQ,
                IP = Config.LocalIp
            };
            return handshakeReq;
        }
    }
}



using AgentWorker.Core;
using AgentWorker.MasterCache;
using BinaryProtocol.Common;
using CTCL.BinaryProtocol.Common.CTCL.Enum;
using System.Data;
using Filetype = AgentWorker.MasterCache.Filetype;

namespace AgentWorker.Global
{
    public static class CacheOnLoad
    {
        //public static void LoadAllCacheData()
        //{
        //    if (Config.IsFileUploadAllowed)
        //    {
        //        ConsoleLog.ConsoleWrite("Filling File Path Statistics");
        //        GetConfiguredFilePath();
        //        ConsoleLog.ConsoleWrite("File Path Statistics Data filled.");
        //    }
        //}
        //public static Response GetConfiguredFilePath()
        //{
        //    Response response = new Response();
        //    try
        //    {
        //        DataSet ds;
        //        ds = CommonHelper.ExecuteProcedureForDataSet("usp_GetFileUploadData");
        //        if (ds == null || ds.Tables.Count == 0)
        //        {
        //            return response.Set(StatusCode.Failure, " no record found.");
        //        }
        //        foreach (DataRow dr in ds.Tables[0].Rows)
        //        {
        //            SegmentId segmentId = new SegmentId();
        //            segmentId._segmentId = Convert.ToInt32(dr[0]);
        //            segmentId._filetype = Convert.ToInt32(dr[1]);


        //            Filetype filetype = new Filetype();
        //            filetype._fileType = Convert.ToInt32(dr[1]);

        //            FileDetails fileDetails = new FileDetails();
        //            fileDetails.SegmentId = Convert.ToInt32(dr[0]);
        //            fileDetails.FileType = Convert.ToInt32(dr[1]);
        //            fileDetails.FilePath = Convert.ToString(dr[2]);
        //            fileDetails.Source = Convert.ToString(dr[3]);
        //            fileDetails.VersionNo = Convert.ToInt32(dr[4]);
        //            fileDetails.LastNoOfRecords = Convert.ToInt32(dr[5]);
        //            fileDetails.FileSizeInBytes = Convert.ToInt32(dr[6]);
        //            fileDetails.FileRefreshFrequency = Convert.ToInt32(dr[7]);
        //            fileDetails.dtmFileLastuploadTime = Convert.ToDateTime(dr[8]);
        //            fileDetails.IsActive = Convert.ToBoolean(dr[9]);
        //            fileDetails.IsDeleted = Convert.ToBoolean(dr[10]);
        //            fileDetails.Remark = Convert.ToString(dr[11]);
        //            fileDetails.UpdatedBy = Convert.ToString(dr[12]);
        //            fileDetails.UpdatedOn = Convert.ToDateTime(dr[13]);

        //            CoreProcess.fileDataCache.AddOrUpdate(fileDetails);

        //        }
        //        return response.Set(StatusCode.Success, "All fileWatchers initialized.");
        //    }
        //    catch (Exception ex)
        //    {
        //        Log.Error($"{ex.Message} | Error while filling File Upload Staistics Data");
        //        return response.Set(StatusCode.Failure, "Error while filling File Upload Staistics Data");
        //    }
        //}
    }
}



using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace AgentWorker.Global
{
    internal class ConsoleLog
    {
        internal static void ConsoleWrite(string message = "")
        {
            if (Console.IsInputRedirected || RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
            {
                Logger.LogInfo(message);
            }
            else
            {
                Console.WriteLine(message);
            }
        }
    }
}

using AgentWorker.Core;
using AgentWorker.Models.Response;
using CTCL.BinaryProtocol.Common.CMA.Enum;
using CTCL.BinaryProtocol.Common.CTCL.Enum;
using CTCL.CacheManagement.ComponentSessionManager;
using CTCL.Utility;

namespace AgentWorker.Global
{
    public class ComponentHandshakeManager
    {
        public void StartHeartBeatChecker()
        {
            Task.Factory.StartNew(() =>
            {
                ManualResetEvent _heartBeatChecker = new ManualResetEvent(false);
                while (true)
                {
                    _heartBeatChecker.WaitOne(Config.heartbeatCheckInterval * 1000);
                    var allComponentSession = CoreProcess.interfaceProcessor.componentSessionManager.Get();
                    if (allComponentSession != null && allComponentSession.Count > 0)
                    {
                        for (int i = 0; i < allComponentSession.Count; i++)
                        {
                            var sessionObj = allComponentSession.ElementAt(i);
                            if (sessionObj != null && sessionObj.componentHandshake != ComponentHandshakeStatus.INACTIVE)
                            {
                                var expriryTime = sessionObj.lastHearBeatRecevieTime.ToCTCLDateTime().AddSeconds(Config.ConfigurationValueAliveInst);
                                if (expriryTime < DateTime.Now)
                                {
                                    sessionObj.componentHandshake = ComponentHandshakeStatus.INACTIVE;
                                    CoreProcess.interfaceProcessor.componentSessionManager.Update(sessionObj);
                                    Disconnect(sessionObj);
                                    Log.Info($"Compnent {sessionObj.ComponentType} | instanceName {sessionObj.instanceId} | Compnent status {sessionObj.componentHandshake}");
                                }
                            }
                        }
                    }
                }
            });
        }
        private void Disconnect(ComponentSession sessionObj)
        {
            CoreProcess.SetIsRunning(sessionObj.ComponentType, sessionObj.instanceId, false);
            ComponentStatus componentStatus = Helper.Helper.PrepareComponentStatus((int)sessionObj.ComponentType, sessionObj.instanceId, (int)CMA_StatusCode.Stopped, "Disconnected because of heartbeat");
            CoreProcess.wsClientManager.Enqueue(componentStatus);
        }
    }
}



using AgentWorker.Core;
using BinaryProtocol.Common;
using System.Data;

namespace AgentWorker.Global
{
    public class Config
    {
        public static string logfile;
        public static int logLevel;
        public static int logFileCount;
        public static ushort prefetchCount;
        public static string port;
        public static int AgentWorkerId;
        public static int BrokerId;
        public static int SiteId;
        public static string LocalIp;
        public static Response response;
        public static int heartbeatCheckInterval;
        public static int ConfigurationValueAliveInst;
        public static bool IsFileUploadAllowed;
        public static string WebSocketUrl;
        public static string MasterPath;
		public static int serviceTimerOut = 100;
        public static bool isFileBODDoneToday;
        public static string RabbitIp;
        public static string RabbitPort;
        public static string RabbitLogin;
        public static string RabbitPwd;
        public static string batchFilePath;

        static Config()
        {
            response = new Response();
            logfile = AppSettingHelper.Configuration["LogFilePath"];
            prefetchCount = Convert.ToUInt16(AppSettingHelper.Configuration["PrefetchCount"]);
            logLevel = Convert.ToInt32(AppSettingHelper.Configuration["LogLevel"]);
            logFileCount = Convert.ToInt32(AppSettingHelper.Configuration["LogFileCount"]);
            port = AppSettingHelper.Configuration["ServerPort"];
            prefetchCount = Convert.ToUInt16(AppSettingHelper.Configuration["PrefetchCount"]);
            heartbeatCheckInterval = Convert.ToInt32(AppSettingHelper.Configuration["heartbeatCheckInterval"]);
            ConfigurationValueAliveInst = Convert.ToInt32(AppSettingHelper.Configuration["ConfigurationValueAliveInst"]);
            IsFileUploadAllowed = Convert.ToBoolean(AppSettingHelper.Configuration["IsFileUploadAllowed"]);
            WebSocketUrl = AppSettingHelper.Configuration["WebSocketUrl"];
            RabbitIp = AppSettingHelper.Configuration["RabbitIp"];
            RabbitPort = AppSettingHelper.Configuration["RabbitPort"];
            RabbitLogin = AppSettingHelper.Configuration["RabbitLogin"];
            RabbitPwd = AppSettingHelper.Configuration["RabbitPwd"];
            batchFilePath = "BatchFiles\\getprocess3.bat";
        }

        //public static Response GetConfigurationSettings()
        //{
        //    DataSet ds;
        //    var dbParams = new Dictionary<string, object>();
        //    dbParams.Add("IP", Config.LocalIp);
        //    ds = CommonHelper.ExecuteProcedureForDataSet("usp_GetCMAAgentConfigMaster", dbParams);
        //    if (ds == null)
        //    {
        //        return response.Set(StatusCode.Failure, "CMAAgentConfigMaster info not loaded.");
        //    }
        //    return FillCMAAgentConfigMaster(ds.Tables[0]);
        //}
        //private static Response FillCMAAgentConfigMaster(DataTable dataTable)
        //{
        //    try
        //    {
        //        foreach (DataRow dr in dataTable.Rows)
        //        {
        //            BrokerId = Convert.ToInt32(dr[0]);
        //            SiteId = Convert.ToInt32(dr[1]);
        //            AgentWorkerId = Convert.ToInt32(dr[2]);
        //        }
        //        Log.Info($"Records fetched from DB for CMAAgentConfigMaster : {dataTable.Rows.Count}");

        //        return response.Set(StatusCode.Success, "CMAAgentConfigMaster config filled successfully.");
        //    }
        //    catch (Exception ex)
        //    {
        //        return response.Set(StatusCode.Failure, "Failed to fill CMAAgentConfigMaster config.");
        //    }
        //}
    }
}


using AgentWorker.Core;
using BinaryProtocol.Common;

namespace AgentWorker.Global
{
    internal class Log
    {
        private static LogType _logType;
        internal Log(LogType logType)
        {
            _logType = logType;
        }

        internal void UpdateLogType(LogType logType)
        {
            _logType = logType;
        }

        internal static void Verbose(object Object, string message = "")
        {
            if (_logType > LogType.Verbose)
            {
                Object = null;
                message = null;
                return;
            }
            LogObject logObject = new LogObject(LogType.Verbose, message, Object);
            CoreProcess.SendToLogQueue(logObject);
        }

        internal static void Debug(object Object, string message = "")
        {
            if (_logType > LogType.Debug)
            {
                Object = null;
                message = null;
                return;
            }
            LogObject logObject = new LogObject(LogType.Debug, message, Object);
            CoreProcess.SendToLogQueue(logObject);
        }
        internal static void Info(string message = "")
        {
            if (_logType > LogType.Info)
            {
                message = null;
                return;
            }

            LogObject logObject = new LogObject(LogType.Info, message);
            CoreProcess.SendToLogQueue(logObject);
        }
        internal static void Warning(object Object, string message = "")
        {
            if (_logType > LogType.Warning)
            {
                Object = null;
                message = null;
                return;
            }
            LogObject logObject = new LogObject(LogType.Warning, message, Object);
            CoreProcess.SendToLogQueue(logObject);
        }
        internal static void Error(object Object, string message = "")
        {
            if (_logType > LogType.Error)
            {
                Object = null;
                message = null;
                return;
            }
            LogObject logObject = new LogObject(LogType.Error, message, Object);
            CoreProcess.SendToLogQueue(logObject);
        }

        internal static void Fatal(object Object, string message = "")
        {
            if (_logType > LogType.Fatal)
            {
                Object = null;
                message = null;
                return;
            }
            LogObject logObject = new LogObject(LogType.Error, message, Object);
            CoreProcess.SendToLogQueue(logObject);
        }
    }
}


using Exchange.Logs;

namespace AgentWorker.Global
{
    public class Logger
    {
        private static LogManager logManager;
        static Logger()
        {
            LogConfiguration logConfiguration = new LogConfiguration
            {
                FilesizeLimitBytes = 50000000,
                LogFileNameWithPath = Config.logfile,
                LoggingLevelSwitch = new Serilog.Core.LoggingLevelSwitch
                {
                    MinimumLevel = Serilog.Events.LogEventLevel.Information,
                },
                OutputTemplate = "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u5}] {Message:lj}{NewLine}{Exception}",
                RetainedFileCount = 0,
                RollingInterval = Serilog.RollingInterval.Infinite,
                RollOnFileSizeLimit = true,
            };

            logManager = new LogManager(logConfiguration);
        }

        public static void LogError(string msg, object logObject)
        {
            logManager.Error(msg, logObject);
        }

        public static void LogInfo(string msg, object logObject = null)
        {
            if (logObject == null)
            {
                logManager.Info(msg);

            }
            else
            {
                logManager.Info(msg, logObject);
            }
        }
    }
}



using System;
using System.CodeDom;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace AgentWorker.Helper
{
	public static class ConsoleHelper
	{
		[DllImport("user32.dll", SetLastError =true)]
		private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
		
		[DllImport("user32.dll", CharSet = CharSet.Auto)]
		private static extern int GetwWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);
		
		[DllImport("user32.dll")]
		private static extern IntPtr GetForegroundWindow();

		[DllImport("user32.dll")]
		private static extern uint GetWindowThreadProcessId(IntPtr hwnd, out uint processId);

		[DllImport("user32.dll")]
		private static extern bool IsWindowVisible(IntPtr hwnd);
		[DllImport("user32.dll", SetLastError = true)]
		private static extern bool EnumWindows(EnumWindowsProc lpEnumFunc, IntPtr lParam);

		private delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);
		public static string GetConsoleName(int processId) 
		{
			string name = string.Empty;
			EnumWindows((hWnd, lparam) =>
			{

				uint processidFound = GetWindowThreadProcessId(hWnd, out processidFound);

				if (processidFound == processId)
				{
					StringBuilder windowTitle = new StringBuilder(256);
					GetwWindowText(hWnd, windowTitle, windowTitle.Capacity);
					Console.WriteLine(windowTitle);
					name=  windowTitle.ToString();
					return false;
				}
				return true;
			}, IntPtr.Zero);

			return name;
		}


	}
}



using AgentWorker.Global;
using AgentWorker.Models.Response;
using BinaryProtocol.Common;
using CTCL.BinaryProtocol.Common.CMA.Enum;
using CTCL.BinaryProtocol.Common.CTCL.Enum;
using Newtonsoft.Json;

namespace AgentWorker.Helper
{
    public class Helper
    {
        public static string SerializeObject(object obj)
        {
            try
            {
                return JsonConvert.SerializeObject(obj);
            }
            catch (Exception ex)
            {
                return "Error in serialize :" + ex.Message;
            }
        }
        public static ComponentStatus PrepareComponentStatus(int compId, int instanceId, int compState, string message, string requestId = "")
        {

            ComponentStatus componentStatus = new()
            {
                MessageCode = (int)CMA_OpCode.COMPONENT_STATE_UPDATE,
                BrokerId = Config.BrokerId,
                SiteId = Config.SiteId,
                AgentId = Config.AgentWorkerId,
                ComponentType = compId,
                InstanceId = instanceId,
                ComponentState = compState,
                Message = message,
                TimeStamp = DateTime.Now,
                IsSucessStatus = true,
                RequestId = requestId
            };
            return componentStatus;
        }
    }
}




using AgentWorker.Core;
using AgentWorker.Global;
using AgentWorker.MasterCache;
using AgentWorker.Models.Response;
using BinaryProtocol.Common;
using CTCL.BinaryProtocol.Common.CMA.Commons;
using CTCL.BinaryProtocol.Common.CMA.Enum;
using CTCL.BinaryProtocol.Common.CMA.Response;
using CTCL.BinaryProtocol.Common.CTCL;
using CTCL.BinaryProtocol.Common.CTCL.Enum;
using CTCL.BinaryProtocol.Common.CTCL.Request;
using CTCL.CacheManagement.ComponentSessionManager;
using CTCL.Utility;
using MQueue;
using Utility;
using ComponentInfo = BinaryProtocol.Common.ComponentInfo;
using InstanceMaster = BinaryProtocol.Common.InstanceMaster;

namespace AgentWorker.Listener
{
    public class ListenerOfMQ
    {
        private Conversion conversion;
        private Compression compression;
        private Queue<byte[]> datafromMQ;
        private MQConfiguration mqConfig;
        private MQConsumer mqConsumer;
        private MQPublisher mqPublisher;
        private string queueName;
        private ushort prefetchCount;
        private string exchangeName;
        private int instanceId;
        private ComponentSession componentSession;

        private Dictionary<string, ComponentInfo> sourceInfo; //ComponenId|InstanceId
        private ComponentType sourceComponentType;
        private InstanceMaster instanceMaster;

        public ListenerOfMQ(QueueConfiguration queueConfig)
        {
            sourceInfo = new Dictionary<string, ComponentInfo>();
            compression = new Compression(0);
            var resp = compression.Initialize();
            if (resp.StatusCode != StatusCode.Success)
            {
                Log.Error(resp, "----ListenerOfMQ ---- compression ---");
                throw new Exception(resp.Message);
            }
            datafromMQ = new Queue<byte[]>();
            prefetchCount = Config.prefetchCount;
            conversion = new Conversion();

            mqConfig = new MQConfiguration
            {
                HostName = new MQHostName { hostname = queueConfig.HostName },
                Password = new MQPassword { password = queueConfig.PassWord },
                Port = new MQPort { port = queueConfig.Port },
                UserName = new MQUserName { username = queueConfig.UserName },
                VirtualHost = new MQVirtualHost { virtualhost = queueConfig.VirtualHost },
                LogFilePath = new MQLogFilePath { filepath = Config.logfile.Replace("\\AgentWorker\\", "\\AgentWorker\\MQ\\") },
                Component = ComponentType.MailSender,
                ExchangeName = new MQExchangeName { exchangename = queueConfig.ExchangeName },
                QueueName = new MQQueueName { queuename = queueConfig.MQName },
            };
            queueName = queueConfig.MQName;
            exchangeName = queueConfig.ExchangeName;
        }

        public Response AddSource(ComponentInfo componentInfo)
        {
            Response response = new Response();
            sourceComponentType = componentInfo.ComponentType;
            instanceId = componentInfo.InstanceId;
            var key = componentInfo.ComponentType + "|" + componentInfo.InstanceId;
            if (!sourceInfo.ContainsKey(key))
            {
                sourceInfo.Add(key, componentInfo);
                return response.Set(StatusCode.Success, "Added Sucessfully.");
            }
            return response.Set(StatusCode.Failure, "Already Exist.");
        }
        public Response Initialize(bool IsAutoAck = true)
        {
            Response response = new Response();
            try
            {
                if (prefetchCount > 0)
                {
                    mqConsumer = new MQConsumer(mqConfig, MqConsumer_evtMessageRecieverEvent, true);
                    response = mqConsumer.ConsumeMQ(IsAutoAck, prefetchCount);
                }
                else
                {
                    mqConsumer = new MQConsumer(mqConfig, MqConsumer_evtMessageRecieverEvent);
                    response = mqConsumer.ConsumeMQ(IsAutoAck);
                }

                if (response.StatusCode != StatusCode.Success)
                {
                    Log.Error(response.Message, "Couldn't Intilize Consumer.");
                    return response.Set(StatusCode.Failure, "Couldn't Intilize Consumer.", mqConfig);
                }

                Log.Debug(response.Message, "MQ Consumer Connected Successfully");
                return response.Set(StatusCode.Success, "MQ Consumer Connected Successfully", mqConfig);
            }
            catch (Exception ex)
            {
                Log.Error(StatusCode.Failure, "MQ Consumer Connection Failed. Error :" + ex.Message);
                return response.Set(StatusCode.Failure, "MQ Consumer Connection Failed. Error :" + ex.ToString());
                //logs
            }
        }
        private void MqConsumer_evtMessageRecieverEvent(ReadOnlyMemory<byte> message, ulong delieveryTag)
        {
            if (message.Length > 0)
            {
                try
                {
                    Log.Info("Writing in the file");
                    PreDeCompressMsgAndSend(message.ToArray());
                }
                catch (Exception ex)
                {
                    Log.Error(null, "Exception occured while writing in file" + ex.Message);
                }
            }
            else
            {
                Log.Error(null, "Message null in mqconsumer");
            }
        }
        private byte[] PreAllocBuffer = new byte[16384];
        private byte[] GetCompressBytesFromMessage(byte[] data)
        {
            var compressBytesRes = compression.Compress(data);
            if (compressBytesRes.StatusCode == StatusCode.Success)
            {
                return (byte[])compressBytesRes.ExtraInfo;
            }
            else
            {
                Log.Error("Failed to compress." + compressBytesRes.Message);
                return null;
            }

        }
        public Response AddInstanceMaster(InstanceMaster instanceMaster)
        {
            Response response = new Response();
            this.instanceMaster = instanceMaster;
            return response.Set(StatusCode.Success, "Added Sucessfully.");
        }
        public void PreDeCompressMsgAndSend(byte[] message)
        {
            try
            {
                var unCompressesBytesRes = compression.Decompress(message);
                if (unCompressesBytesRes.StatusCode == StatusCode.Success)
                {
                    var unCompressesBytes = (byte[])unCompressesBytesRes.ExtraInfo;
                    int counter = unCompressesBytes.Length;
                    int index = 0;
                    while (counter != 0)
                    {
                        //Take length;
                        var length = BitConverter.ToInt32(unCompressesBytes, index);
                        counter = counter - sizeof(int);
                        index = index + sizeof(int);
                        var byteMsg = new byte[length];
                        Buffer.BlockCopy(unCompressesBytes, index, byteMsg, 0, length);

                        counter = counter - length;
                        index = index + length;

                        var opcode = BitConverter.ToInt16(byteMsg, 0);
                        bool isHandshakeOpcode = HandleComponentHandshake(opcode, byteMsg);
						if (!isHandshakeOpcode)
						{

                            Log.Info($"Message Recevied from {sourceComponentType}");
							switch (sourceComponentType)
							{
                                case ComponentType.CONTRACT_MASTER_READER:
                                    ProcessContractMasterResponse(opcode, byteMsg);
									break;
                                case ComponentType.DBWriter:
                                case ComponentType.OMS:
                                case ComponentType.MailSender:
                                case ComponentType.RMS:
                                case ComponentType.AdminApi:
                                case ComponentType.PBS:
                                case ComponentType.SBS:
                                case ComponentType.NSECMBroadCastGateway:
                                case ComponentType.BroadcastGateway:
                                case ComponentType.MasterAPI:
                                case ComponentType.RMSApi:
                                case ComponentType.IBTInteractiveApi:
                                case ComponentType.IBTMarketApi:
                                case ComponentType.TradingApi:
                                case ComponentType.MarketApi:
                                case ComponentType.NSECMInteractiveGateway:
                                case ComponentType.NSEFOInteractiveGateway:
                                case ComponentType.LoadBalancer:
                                case ComponentType.SFTPServer:
                                    ProcessOMSResponse(opcode, byteMsg);
                                    break;
                                default : 
                                    // handle component status for all components
                                    break;
							}
						}
					}
                }
                else
                {
                    Log.Error(null, $"Unable to compress message {unCompressesBytesRes.Message}");
                }
            }
            catch (Exception ex)
            {
                Log.Error(null, "Exception occured while processing meaage from mq consumer" + ex.Message);

            }

        }
        public (ComponentType, int) GetComponentInfo()
        {
            return (sourceComponentType, instanceId);
        }
        public Response AddComponentSession(ComponentSession componentSession)
        {
            Response response = new Response();
            this.componentSession = componentSession;
            return response.Set(StatusCode.Success, "Added Sucessfully.");
        }
        private bool HandleComponentHandshake(short opcode, byte[] byteMsg)
        {
            bool isHandshakeOpcode = false;
            switch ((CTCL_OpCode)opcode)
            {
                case CTCL_OpCode.HeartBeat:
                    {
                        isHandshakeOpcode = true;
                        if (componentSession != null)
                        {
                            var heartBeat = conversion.FromBytesToObject<CTCL_Heartbeat_Req>(byteMsg);
                            componentSession.lastHearBeatRecevieTime = heartBeat.MessageHeader.TimeStamp.TimeStamp;
                        }

                    }
                    break;
                case CTCL_OpCode.COMPONENT_STATUS_UPDATE:
                    isHandshakeOpcode = true;
                    if (componentSession != null)
                    {
                        var statusUpdate = conversion.FromBytesToObject<CTCL_Heartbeat_Req>(byteMsg);
                        componentSession.componentHandshake = statusUpdate.ComponentHandshakeStatus;
                        if (componentSession.componentHandshake == ComponentHandshakeStatus.READY_TO_ROUTE)
                        {
                            Log.Info($"Component {componentSession.ComponentType} is connected");
       //                     if(!CoreProcess.GetIsRunning(componentSession.ComponentType, instanceId))
       //                     {
							//	CoreProcess.SetExistingProcess(componentSession.ComponentType, instanceId);
       //                         // If the component is stopped and user manually restart it than in this case is attact the process 
							//}
                        }
                        //SendComponentStatus(statusUpdate.MessageHeader, statusUpdate.ComponentHandshakeStatus);
                    }
                    break;

                default:
                    break;
            }
            return isHandshakeOpcode;
        }

        private void ProcessContractMasterResponse(short opcode, byte[] byteMsg)
        {
			switch ((CTCL_OpCode)opcode)
			{
				case CTCL_OpCode.FILE_UPLOAD_START_ACKNOWLEDGEMENT:
                    var fileStartRequest = conversion.FromBytesToObject<CMA_FileUploadResponse>(byteMsg);
                    var feReq = ConvertFileUploadResponse(fileStartRequest);
                    if (feReq.Item1)
                    {
                        CoreProcess.wsClientManager.Enqueue(feReq.Item2);
                    }
                    break;
				case CTCL_OpCode.FILE_UPLOAD_END_ACKNOWLEDGEMENT:
					var fileEndRequest = conversion.FromBytesToObject<CMA_FileUploadResponse>(byteMsg);
					var feEndReq = ConvertFileUploadResponse(fileEndRequest);
                    if (feEndReq.Item1)
                    {
                        CoreProcess.wsClientManager.Enqueue(feEndReq.Item2);
                    }
                    break;
                case CTCL_OpCode.CMA_COMPONENT_STATUS:
                    {
                        ProcessOMSResponse(opcode, byteMsg);
                    }
                    break;
				default:
					break;
			}
		}

        private (bool,FileStatus) ConvertFileUploadResponse(CMA_FileUploadResponse fileupload)
        {
            var fileName = string.Empty;
            var res = CoreProcess.filePathInfo.Where(x => x.Segment == fileupload.SegmentId.SegmentId && x.FileType == fileupload.FileType.id).FirstOrDefault();
            if(res == null)
            {
                Log.Error($"Could not find file info for segment {fileupload.SegmentId.SegmentId} and file type {fileupload.FileType.id}");
                return (false, null);
            }
            //         var res = CoreProcess.fileDataCache.Get(fileupload.SegmentId.SegmentId, fileupload.FileType.id);
   //         if (res.Item1)
   //         {
   //             fileName = res.Item2.Remark;
			//}

			FileStatus fileStatus = new();
            fileStatus.MessageCode = (int)CMA_OpCode.FILE_UPLOAD_CONFIRMATION;
            fileStatus.BrokerId = Config.BrokerId;
            fileStatus.SiteId = Config.SiteId;
            fileStatus.AgentId = Config.AgentWorkerId;
            fileStatus.FileName = res.FileName;
            fileStatus.FileType = fileupload.FileType.id;
            fileStatus.Segment = fileupload.SegmentId.SegmentId;
            fileStatus.IsSucessStatus = fileupload.StatusCode == StatusCode.Success ? true : false;
            fileStatus.Message = fileupload.StatusMessage.Message.ToTruncateEndString();
            fileStatus.TimeStamp = fileupload.TimeStamp.TimeStamp.ToCTCLDateTime();

            for(int i=0; i<CoreProcess.filePathInfo.Count; i++)
            {
                if (CoreProcess.filePathInfo[i].FileType == fileupload.FileType.id
                    && CoreProcess.filePathInfo[i].Segment == fileupload.SegmentId.SegmentId)
                {
                    if (fileupload.MessageHeader.OpCode == CTCL_OpCode.FILE_UPLOAD_END_ACKNOWLEDGEMENT)
                    {
                        CoreProcess.filePathInfo[i].IsFileUploadAck = true;
                    }
                    
                }
            }

            return (true,fileStatus);
		}
        private void ProcessOMSResponse(short opcode, byte[] byteMsg)
        {
            switch ((CTCL_OpCode)opcode)
            {
                case CTCL_OpCode.CMA_COMPONENT_STATUS:
                    {
                        var componentUpdate = conversion.FromBytesToObject<CMA_COMPONENT_MESSAGE_UPDATE>(byteMsg);
                        if(componentUpdate != null)
                        {
                            var resp = Helper.Helper.PrepareComponentStatus(componentUpdate.MessageHeader.SourceComponentIdentifier.ComponentId,
                                componentUpdate.MessageHeader.SourceComponentInstance.ComponentInstanceId,
                                (int)componentUpdate.SuccessFailureFlag, componentUpdate.ResponseString.Message.ToTruncateEndString(),
                                componentUpdate.RequestID.RequestId.ToTruncateEndString());
                            if (componentUpdate.SuccessFailureFlag == CMA_StatusCode.Completed)
                            {
                                CoreProcess.SetIsRunning((ComponentType)componentUpdate.MessageHeader.SourceComponentIdentifier.ComponentId, componentUpdate.MessageHeader.SourceComponentInstance.ComponentInstanceId, true);
                            }
                            CoreProcess.wsClientManager.Enqueue(resp);
                        }
                    }
                    break;
            }
        }
    }
}








